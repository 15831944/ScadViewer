#ifndef ARM_REZ_H
#define ARM_REZ_H
#define KFP 30      /* кол-во элементов массива продольной ар-ры */
#define KF4 24      /* кол-во элементов массива поперечной ар-ры */
#define KSYZ 2      /* кол-во элементов массива шагов поперечной ар-ры */
#define KU   6      /* кол-во элементов массива площадей угловых стержней */
#define KPS  4      /* кол-во элементов массива к-ва промежут. стержней*/

/*************** структуры для записи результатов армирования *********/
struct ArmKol
         { int Kel;       // общее к-во КЭ
           int KGr;       // к-во групп исходных данных
           long IndRez;    // смещение от нач. файла на результаты армирования
		   int SnipF;     // флаг по нормам - признак СНиПа	(0-Укр 84, 1-Россия 84, 2-Россия 2003)
         };                // после всех индексных массивов

 struct ArmEl
         { int Kar;       //  к-во КЭ для армирования в индексном массиве по группе
           long AddInd;    // смещение от начала файла индексного мас. по группе
		   int SeismF;	// 0-нет, 1-флаг о наличии сейсмических загружений в РСУ в КЭ группы для СП
         };
 struct ArmInd
         {
                 char IsArm;     // 1 - элемент пpоаpмиpован, 0 - нет
                 char WhatEl;    // 1 - стеpжень, 2 - пластина,  0 - спец. элемент
                 int  NomEl;     // номер КЭ
                 long Index;     //  Смещение инфоpмации о pезультатах аpмиpования
                                                          // от начала файла  (дпя стеpжней -1)
                 long LenRez;    // длина в байтах результатов армирования
                 WORD KolRez;// к-во записей =  или  kd (количество сечений kd)
                              // или   2*kd  или другое
                              // ( LenRez-sizeof(T_GRA_REP) ) / sizeof(T_GRA)
         };

typedef  struct   /* структура ceгментируемого ключа */
          {
                 int i,           /*   1-й сегмент short unsigned*/
                     j;           /*   2-й сегмент */
          } KEY_SEG;

typedef struct           /* повторная информация */
  {
        KEY_SEG  key;    /* ключ зап. повт. инф.: номер эл-та ( 1-й сегмент)  */
                                                  /* ( 2-й сегмент) = 0                                */
        short    nma;         /* номер модуля армирования */
        double   cb;          /* класс бетона             */
        char     vb[16];       /* вид бетона               */
        char     pa[16];       /* класс продольной арматуры*/
        char     pax[16];      /* класс поперечной арматуры*/
        double   a1,a2;       /* защитные слои            */
        double   a3,a4;       /* защитные слои для плит   */
        int      ps;          /* признак сечения          */
        double   b,h,b1,      /* размеры сечения          */
                 h1,b2,h2;
        short    lat;         /* lat==0 расчета по трещинам нет  */
        WORD     kd;          /* количество сечений                */
        int      ngr;         /* номер группы исходных данных      */
		char     cbet[16];  /* !!!класс бетона - B12.5 (например) - пока не заполнено  */
		char     mbet[16];  /* !!!марка легкого бетона - D800 (например) - пока не заполнено  */

        short    NClassPro;   // номер класса прод. ар-ры в списке из всех классов
        short    NClassPop;   // номер класса поп. ар-ры в списке из всех классов
        DWORD    ArAuto;      // метод подбора ар-ры (0 - старый, 1 - от мин. к-ва стержней до максим.)
        double   MaxDiam;     // макс. диаметр арматурн. продольного стержня, в мм
        double   Sdiam;       // площадь максим. армат. продольн. стержня, в см**2
        double   MaxDPop;     // макс. диаметр арматурн. поперечн. стержня, в мм
        double   SdPop;       // площадь максим. армат. поперечн. стержня, в см**2
		int      Snip;      // флаг по нормам - признак СНиПа	(0-Укр 84, 1-Россия 84, 2-Россия 2003)
		int      rez1;		  //  часть от rez + Snip = 8 байт
        double    rez0[9];    // резерв было 10 штук
  } T_GRA_REP;

typedef struct      /* индивидуальная информация */
  {
         KEY_SEG key;           /* номер эл-та      (ключ - 1-й сегмент)  */
                                /* номер сечения    (ключ - 2-й сегмент)  */
         double        fpro[KFP]; /* продольная арматура      */
         double        fpop [KF4];/* поперечная арматура      */
         double        sazym[KSYZ]; /* шаг попер. ар-ры */
         double        fproS [KFP]; /* продольная арматура по СНИП  */
         short        sm;       /* признак сеч. мало */
         short        nug;       /* номер унифицированной группы */
         short        jtr;      /* признак сеч. мало по трещ. */
         short        kr;       /* признак кручения */
         short        ktr;      /* признак строки по трещ. */
         double        fproU[KU]; // не симм.[0]:[3] - AS1i, AS2i, AS3i, AS4i;
         							  // симм. [4]:[5] - AS1i, AS3i
         double        kps[KPS];  // к-во промежуточных стержней на стороне сечения (несим.ар-ие)
         	// [0] - к-во промежуточных стержней на стороне AS1
            // [1] - к-во промежуточных стержней на стороне AS2
         	// [2] - к-во промежуточных стержней на стороне AS3
            // [3] - к-во промежуточных стержней на стороне AS4
         short        SkvozTr;  //  признак версии ==0 прочн. без круч.; ==1 с кручением
								//	при дискретном подборе по прочности в каждый стержень
								//  автоматич. суммируется площадь, подобранная от кручения
		 double       koef[48]; /* коеф. экспертизы по СНИП - пока нет */
					  // при lah==1 - заполняются koef[0 : 3]- % изменения AS1,AS2,AS3,AS4 
         short        Imax;  // номер в массиве коэффициентов макс. фактора KMAX = koef[Imax] (bilo rezerv)
         short        ImaxPro;  // номер в массиве коэффициентов макс. фактора KMAX = koef[Imax]
	     short        ImaxPop;  // номер в массиве коэффициентов макс. фактора KMAX = koef[Imax]
		 long  lenDiam; // sizeof(struct DISKRET)- длина в байтах результатов 
						// дискретного подбора по СП, записывается сразу за T_GRA, если 
						// = 0, то этой информации нет 
		 double       kpsim[2];  //  к-во промеж. стержней при сим. ар-ии на кажд. стороне сеч.
		 double       rez[2]; /* резерв bilo 4 - 2 ушло в kpsim,5 -1 ушло в LenDiam и rez1*/
  } T_GRA;

//	результаты дискретного подбора (пока СП 52-101-2003) в процессе работы будут изменения !!!
//  ПОКА ЭТА СТРУКТУРА НЕ ЗАПИСЫВАЕТСЯ и в структуре T_GRA поле lenDiam==0  
struct DISKRET
{		
    // ПРОЧНОСТЬ  // KU = 6,[0]-[3]- несим ар-ие,[4],[5] - сим армир-ие
    double   FpsUNoSim[2]; //S1,S2-площади угловых стержней - пока не заполн
    double   DpsUNoSim[2]; //D1,D2-диаметры угловых стержней - пока не заполн
    double   FpsUSim; // площади угловых стержней - пока не заполняется
    double   DpsUSim; //диаметры угловых стержней - пока не заполняется
	
    double   Fps[KU]; // площади промежуточных стержней - пока не заполн
    double   Dps[KU]; // диаметры промежуточных стержней - пока не заполн
    short	PrDUNoSim[2]; // 0-хорошо, 1-признак- площадь 1 угл. стерж.> максим. диам. -несим ар-ие
    short	PrDNoSim[KPS];  // 0-хорошо, 1-признак- площадь 1 промеж стерж.> максим. диам. -несим. ар-ие
							// KPS=4
    short	PrDUSim; // 0-OK, 1-признак- площадь 1 угл. стерж.> максим. диам. -сим
    short	PrDSim[2];  // 0-OK, 1-признак- площадь 1 промеж стерж.> максим. диам. -сим
	
	// Прочность + ТРЕЩИНОСТОЙКОСТЬ 	
	double   FpsUNoSimT[2];//S1,S2-площади угловых стержней - пока не заполн
    double   DpsUNoSimT[2];//D1,D2-диаметры угловых стержней - пока не заполн
    double   FpsUSimT; // площади угловых стержней - пока не заполняется
    double   DpsUSimT; //диаметры угловых стержней - пока не заполняется
    double   FpsSimT[KU]; // площади промежуточных стержней - пока не заполняется	
    double   DpsSimT[KU]; // диаметры промежуточных стержней - пока не заполняется	
    short   kpsT[KU];  // к-во промежуточных стержней на стороне сечения
	// [0] - к-во промежуточных стержней на стороне AS1
	// [1] - к-во промежуточных стержней на стороне AS2
	// [2] - к-во промежуточных стержней на стороне AS3
	// [3] - к-во промежуточных стержней на стороне AS4
	// [4] - к-во промежуточных стержней на стороне AS1-cим
	// [5] - к-во промежуточных стержней на стороне AS3-сим
}; 			

  typedef T_GRA     T_ARM;
  typedef T_GRA_REP T_ARM_REP;

#endif
